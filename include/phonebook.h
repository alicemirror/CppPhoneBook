/**
	\file phonebook.h
	\brief PhoneBook class header file.
	
	This file includes the class definition, methods and other header constants
	used by the class and available to the application.
	
*/

#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <utility>
#include "phonebook_const.h"

#ifndef _PHONEBOOK
#define _PHONEBOOK

// Undef below to remove console debug messages output
#undef _CLASS_DEBUG

/**
	Definition of the header fields of the phonebook entry.
	
	Here, the base fields are defined as std::strings, better
	managed than just char*, as well as some useful controls like
	the buffer overrun, possibiility to concatenate them and seems faster
	than memory allocated strings. The ID is the data value associated to the
	key in the maps connected to the header structure to make the EntryHeader
	field definition.
*/
struct EntryHeader {
		std::string name;
		std::string surname;
		std::string phone;
		int id;
};

/**
	The main phonebook class, including the data structure
	
	In a more realistic application we should expect that the
	EntryHeader structure – here used as the vector to store the entries
	data – will be replaced by some sort of external structure like a
	database.

	The class exposes a series of API methods supporting the features as
	described in the requirements.
	
	\note The dataset is initialized to empty (both data and associtated maps)
	to ensure the fully reusability of the class when it is instantiated.
	The API cleanDataSet() can be used to delete the entire dataset when the
	class is in use.
	
	\todo Add the modifyEntry() method
*/
class PhoneBook {
	
public:
	/** 
		Class constructor.
		The constructor initializaes the data container and the associated
		maps.
	*/
	PhoneBook(void);
	
	/**
		Empty the dataset and the associated maps to set the same condition
		when the class has been instantiated. As we use vectors and maps, this
		function will also free the memory allocated by the data that will be
		erased.
	*/
	void cleanDataSet();
	
	/**
		Add a new entry to the data structure. The addition also updates the
		maps content. By this way, any new entry position in the current list
		is added as the value in the map.
		
		\note There is no control on the presence of duplicated entries as it
		should be considered the possibility of synonims. A duplicate entry
		will reside in a different position of the data vector and has at least
		a unique id.
		
		\warning The addEntry() method expect that the EntryHeader fields are
		filled with correct data (eventually a coherence control should be added
		in a future version) but the method don't care of the id field
		(if still existing is replaced) managed by the internal id counter.
		
		\param entry A pointer to the filled EntryHeader to store in the vector
		\return The index of the new entry in the dataset or a negative
		number with the error code.
		
		\todo Implement data coherence control and manage error codes exits conditions.
	*/
	int addEntry(EntryHeader *entry);
	
	/**
		Remove an entry from the data structure based on its index.
		
		As the position of the elements in the vector may change on elements
		deletion, the map indexes are regenerated by the function.
		
		\param id The entry index to remove
		\return The index of the deleted entry or a negative number with the
		error code
		
		\todo Implement data coherence control and manage error codes exits conditions.
	*/
	int deleteEntry(int id);
	
	//! Rebuild the map indexes of the byName and bySurname maps.
	//! Used when an entry has been deleted from the dataset.
	void remapIndexes();
	
	/**
		Search for the first instance of the entry corresponding to the key.
		
		\note The search is done on the bySurname map, that is the less frequently
		duplicated field (due to synanimia).
		
		\param key The key search string
		\return The entry ID or -1 if not entry has been found.
	*/
	int searchForDelete(std::string key);
	
	/**
		Search for all the ocurrencies starting with the search key and
		update the vector list. The search can be done on the name or surname
		map.
		
		\param key The search key string
		\param list The vector reference that will be filled with the list
		of the IDs of the found objects
		\param orderType The list can be ordered by ORDER_NAME or ORDER_SURNAME 
		\return An integer with 0 if the search has been completed or a
		negative number identifying the error code.
	*/
	int searchForId(std::string key, std::vector<int> *list, int orderType);
	
	/**
		Retrieve the whole dataset IDs in alphabetical order. The list can be
		generated ordered by name or surname.
		
		\param list The vector reference that will be filled with the list
		of the IDs od the found objects
		\param orderType The list can be ordered by ORDER_NAME or ORDER_SURNAME 
	*/
	void getOrderedId(std::vector<int> *list, int orderType);
	
	/**
		Get the entry corresponding to the selected id. This method can be used
		by the program caller to find the effective data associated by the lists
		of id retrieved by the other methods.

		\param id The entry ID to retrieve
		\param entry The entry object filled with the result data
		\return 0 or the error code
	*/
	int getEntry(int id, EntryHeader *entry);
	
	/**
		Convert a string to all lowercase characters. Used to create the map
		keys for searching ignoring the UC/LC characters. The same method should
		be used setting the search keys by the calling program.
		
		\param uc Source string including eventually one or more uppercase char
		\return The source string with all the characters converted to lowercase
	*/
	std::string toL(std::string uc);
	
private:
#ifdef _CLASS_DEBUG
	//! Dunp the content of the name map
	void dumpMapByName();
	//! Dunp the content of the surname map
	void dumpMapBySurname();
#endif

	/**
		It is the counder of the last ID added to the data set. The ID is
		incremented after every insertion and \e never \e should be decreased.
		The dataIndex is a progressive counter that grant the coherence between the
		positional index of the elements when some are removed from
		the dataset.
	*/
	int dataIdCounter;
	
	//! The vector including the whole data set.
	std::vector<EntryHeader> dataEntries;

	/** 
		The mapped dataset where the key is the name field
		and the value is the corresponding position in the dataset. 
		The map key value is the name string to which the corresopnding dataIdCOunter
		(independent by the physical position of the element in the vector) 
		is appended in the format <Key string>@<counter> This makes unique every
		element of the map permitting the presence of elements duplicated.
	*/
	std::map<std::string, int> byName;

	/** 
		The mapped dataset where the key is the surname field
		and the value is the corresponding position in the dataset. 
		The map key value is the name string to which the corresopnding dataIdCOunter
		(independent by the physical position of the element in the vector) 
		is appended in the format <Key string>@<counter> This makes unique every
		element of the map permitting the presence of elements duplicated.
	*/
	std::map<std::string, int> bySurname;
};

#endif